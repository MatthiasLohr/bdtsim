# This file is part of the Blockchain Data Trading Simulator
#    https://gitlab.com/MatthiasLohr/bdtsim
#
# Copyright 2020 Matthias Lohr <mail@mlohr.com>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from typing import Any, Generator, Tuple

from ecdsa.curves import SECP256k1  # type: ignore
from ecdsa.keys import SigningKey  # type: ignore
from hashlib import sha1

n = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141


def build_hash_int(x: bytes) -> int:
    h = sha1()
    h.update(x)
    return to_int(h.hexdigest())


def to_int(x: Any) -> int:
    return int(x, 16)


def mod_inv(x: int, p_n: int = n) -> int:
    """modular multiplicative inverse (requires that n is prime)"""
    return pow(x, p_n - 2, p_n)


def k_candidates(p_s1: int, p_z1: int, p_s2: int, p_z2: int, p_n: int = n) -> Generator[int, None, None]:
    # the two k candidates which aren't just negations of themselves
    z1_z2 = p_z1 - p_z2
    yield z1_z2 * mod_inv(p_s1 - p_s2, p_n) % p_n
    yield z1_z2 * mod_inv(p_s1 + p_s2, p_n) % p_n


def privkey_k_candidates(p_r: int, p_s1: int, p_z1: int, p_s2: int, p_z2: int,
                         p_n: int = n) -> Generator[Tuple[int, int, int], None, None]:
    """ generates two tuples, each with (privkey, k_possibility_1, k_possibility_2)"""
    mod_inv_r = mod_inv(p_r, p_n)
    for i_k in k_candidates(p_s1, p_z1, p_s2, p_z2, p_n):
        yield (p_s1 * i_k - p_z1) * mod_inv_r % p_n, i_k, -i_k % p_n


sk = SigningKey.generate(curve=SECP256k1)  # private key
vk = sk.verifying_key  # public key
print("public key x=", vk.pubkey.point.x())
print("public key y=", vk.pubkey.point.y())

print("private key number =", int(sk.to_string().hex(), 16))

m1 = b"message"
m2 = b"arsch"
z1 = build_hash_int(m1)
z2 = build_hash_int(m2)

print("z1=", z1)
print("z2=", z2)
signature = sk.sign(m1, k=2, hashfunc=sha1)
r = to_int(signature[:32].hex())
s1 = to_int(signature[32:].hex())
print("r =", r)
print("s1=", s1)
assert vk.verify(signature, m1, hashfunc=sha1)
signature2 = sk.sign(m2, k=2, hashfunc=sha1)
s2 = to_int(signature2[32:].hex())
print("s2=", s2)
assert vk.verify(signature2, m2, hashfunc=sha1)

k = (z1 - z2) * mod_inv(s1 - s2) % n
print('k = {:x}'.format(k))
print('privkey = {:x}'.format((s1 * k - z1) * mod_inv(r) % n))  # these two should
print('privkey = {:x}'.format((s2 * k - z2) * mod_inv(r) % n))  # be the same
